import numpy as np

from .preferences import no_preference
from .selection_methods import nearest, random


def make_policy(preferences=no_preference, selection_methods=nearest):
    """ Make a policy that selects a square with the lowest probability based on the `preference` using the given
        `selection_methods`. The workings are as follow: if an optimal square is in the preference area, generated by
        `preferences`, it is selected. If multiple such squares exist, `selection_method` selects one. If no
        such square exists, the next preference is tried, defaulting to random if no preference fits.
        Some example policies can be found in `policies.policies`.

        :param preferences: A function or a list of functions that takes in the probability array and returns a mask for
                            the squares it would like to select. If a list is given, each preference method is used in
                            order until one returns a non-empty selection. If no valid selection is made, an optimal
                            square is chosen at random. Some examples can be found in `policies.preferences`.
        :param selection_methods: A function or list of functions that takes the preference mask and selects from and
                                  returns a mask of the selected squares. If there are multiple squares selected, select
                                  again from those squares using the next selection method. If no single square is
                                  selected by the end, a random one is chosen. Some examples can be found in
                                  `policies.selection_methods.`
    """
    def template(preferences, selection_methods, prob):
        best = prob == np.nanmin(prob)
        for preference_selector in preferences:
            preferred = preference_selector(prob)
            preferred = preferred & best    # Now only look at those that have optimal probabilities.
            if preferred.any():
                for selection_method in selection_methods:
                    preferred = selection_method(preferred, prob)
                    ys, xs = preferred.nonzero()
                    if len(xs) == 1:
                        return xs[0], ys[0]

    # Convert the non-list cases to a list case.
    if not isinstance(preferences, list):
        preferences = [preferences]
    if not isinstance(selection_methods, list):
        selection_methods = [selection_methods]
    # And always end with the `no_preference` selector and `random` selection method.
    preferences.append(no_preference)
    selection_methods.append(random)
    return lambda prob: template(preferences, selection_methods, prob)
